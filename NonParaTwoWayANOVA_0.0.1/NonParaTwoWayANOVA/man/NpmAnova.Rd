% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MainFunction.R
\name{NpmAnova}
\alias{NpmAnova}
\title{Create Main Model and Compute P-Values}
\usage{
NpmAnova(
  df_encoded,
  main_vars,
  response,
  learning_rate = NULL,
  max_iter_main = 1000,
  max_iter_interaction = 1000,
  patience = 5,
  n_permutations = 100,
  compute_p_values = TRUE
)
}
\arguments{
\item{df_encoded}{A data frame containing the dataset with one hot encoded(0 and 1) variables.}

\item{main_vars}{A character vector of main effect variable names.}

\item{response}{A string specifying the name of the response variable.}

\item{learning_rate}{A numeric vector for the learning rates (if NULL, (0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7) will be is used).}

\item{max_iter_main}{An integer specifying the max iterations for main effects (default = 1000).}

\item{max_iter_interaction}{An integer specifying the max iterations for interaction effects (default = 1000).}

\item{patience}{An integer specifying early stopping patience (default = 5).}

\item{n_permutations}{An integer for the number of permutations in p-value calculation (default = 100).}

\item{compute_p_values}{A logical value (TRUE/FALSE) indicating whether to run permutation testing (default = TRUE).}
}
\value{
A list containing:
\item{model}{The trained model.}
\item{p_values}{A list of p-values for main and interaction variables (if \code{compute_p_values = TRUE}).}
}
\description{
This function takes user input (dataset, variables, and hyperparameters),
validates the inputs, create a model, and computes p-values for feature importance.
}
\examples{
library(caret)
library(NonParaTwoWayANOVA)
# Create Example Data set
data_generation <- function(n) {
 # Data Generation Function

 # Two categorical variables with 2 levels each
 factorA <- factor(sample(c("A1", "A2"), n, replace = TRUE))
 factorB <- factor(sample(c("B1", "B2"), n, replace = TRUE))

 # Generate interaction effects and response variable
 mu <- 50  # Global mean
 effectA <- c(A1 = 1, A2 = 0)
 effectB <- c(B1 = 3, B2 = -10)
 interaction_effect <- matrix(c(2, -2, -2, 2), nrow = 2, byrow = TRUE,
                              dimnames = list(c("A1", "A2"), c("B1", "B2")))

 # Generate response variable (dependent variable)
 y <- mu + effectA[factorA] + effectB[factorB] +
   mapply(function(a, b) interaction_effect[a, b], factorA, factorB) +
   rexp(n,0.2)  # Adding random noise

 # Create data frame
 df <- data.frame(factorA, factorB, y)
 # Apply one-hot encoding
 dummies <- dummyVars(~ factorA + factorB , data = df)
 encoded_data <- predict(dummies, newdata = df)
 head(encoded_data)

 # Convert to data frame
 response ="y"
 encoded_df <- as.data.frame(encoded_data)
 df_encoded <- cbind(df[response], encoded_df)

 df_encoded=df_encoded[,c("y", "factorA.A1", "factorB.B1")]

 head(df_encoded)

 main_vars <- c( "factorA.A1", "factorB.B1")

 ncol(as.data.frame(df_encoded[, main_vars]))
 return(df_encoded)
}

df_encoded <- data_generation(n = 100)
main_vars <- c("factorA.A1", "factorB.B1")
response <- "y"
set.seed(100)
# call NpmAnova with proper arguments
result <- NpmAnova(df_encoded,
                  main_vars,
                  response,
                  compute_p_values = TRUE)
print(result)
}
